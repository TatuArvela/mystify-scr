<!DOCTYPE html>
<!--
  Recreation of MYSTIFY.SCR in HTML5.
  Created by Tatu Arvela, 2019.
  Original Copyright (C) Microsoft Corp. 1991 - 1998
-->
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
  <meta http-equiv='X-UA-Compatible' content='ie=edge'>
  <title>MYSTIFY.SCR</title>
  <style>
    body {
      background: gray;
      margin: 0;
      display: block;
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden
    }

    canvas {
      display: block;
      transform-origin: top left;
      image-rendering: crisp-edges;
    }
  </style>
</head>

<body>
<canvas id='ðŸŽ¦'></canvas>
<script>
  let FRAME_INTERVAL, START_TIME, NOW, THEN, ELAPSED, WIDTH, HEIGHT
  const SCALE = 1
  const FPS = 24

  const MARGIN = 100
  const MIN_SPEED = 4
  const MAX_SPEED = 12
  const SHAPE_COUNT = 2
  const NODE_COUNT = 4
  const POINT_COUNT = 5

  let SHAPES = []
  const CANVAS = document.getElementById('ðŸŽ¦')
  const C = CANVAS.getContext('2d')

  document.title = 'MYSTIFY.SCR'

  const FAVICON = document.createElement('link');
  FAVICON.type = 'image/x-icon';
  FAVICON.rel = 'shortcut icon';
  FAVICON.href = 'mystify16.png';
  document.getElementsByTagName('head')[0].appendChild(FAVICON);

  CANVAS.style.transform = `scale(${1 / SCALE})`;


  /* -------------------------------------------------------------------------- */


  function Color() {
    this.r = Math.floor(Math.random() * 235) + 20
    this.g = Math.floor(Math.random() * 235) + 20
    this.b = Math.floor(Math.random() * 235) + 20
    this.toString = function () {
      return '#' +
        this.r.toString(16) +
        this.g.toString(16) +
        this.b.toString(16)
    }
  }

  function Speed(x, y) {
    this.x = x || (Math.floor(Math.random() * (MAX_SPEED - MIN_SPEED)) + MIN_SPEED)
    this.y = y || (Math.floor(Math.random() * (MAX_SPEED - MIN_SPEED)) + MIN_SPEED)
  }

  function Point(x, y, speed) {
    this.x = x || (Math.floor(Math.random() * (WIDTH - MARGIN - MARGIN)) + MARGIN)
    this.y = y || (Math.floor(Math.random() * (HEIGHT - MARGIN - MARGIN)) + MARGIN)
    this.speed = speed || new Speed()
  }

  function Node() {
    this.points = []
    let point = new Point()
    for (let i = 0; i < POINT_COUNT; i++) {
      this.points.push(new Point(
        point.x + (point.speed.x * i),
        point.y + (point.speed.y * i),
        JSON.parse(JSON.stringify(point.speed))
      ))
    }
  }

  function Shape() {
    this.color = new Color()
    this.nextColor = new Color()

    this.nodes = []
    for (let i = 0; i < NODE_COUNT; i++) {
      this.nodes.push(new Node())
    }
  }


  /* -------------------------------------------------------------------------- */


  function stepColorComponent(current, next) {
    if (current > next) {
      return current - 1
    } else if (current < next) {
      return current + 1
    } else {
      return current
    }
  }

  function stepColor(shapeGroup) {
    shapeGroup.color.r = stepColorComponent(
      shapeGroup.color.r,
      shapeGroup.nextColor.r
    )
    shapeGroup.color.g = stepColorComponent(
      shapeGroup.color.g,
      shapeGroup.nextColor.g
    )
    shapeGroup.color.b = stepColorComponent(
      shapeGroup.color.b,
      shapeGroup.nextColor.b
    )

    if (shapeGroup.color.r === shapeGroup.nextColor.r
      && shapeGroup.color.g === shapeGroup.nextColor.g
      && shapeGroup.color.b === shapeGroup.nextColor.b) {
      shapeGroup.nextColor = new Color()
    }
  }

  function calculateSpeedReduction(targetAxisSpeed, otherAxisSpeed, otherAxisPosition, cutOffValue) {
    return Math.floor(targetAxisSpeed - (targetAxisSpeed * ((otherAxisPosition - cutOffValue) / otherAxisSpeed)))
  }

  function calculateNextSpeed(point, siblings, index) {
    if (index === POINT_COUNT - 1) {
      return (point.speed === siblings[POINT_COUNT - 2].speed)
        ? new Speed()
        : new Speed(
          Math.abs(siblings[POINT_COUNT - 2].speed.x),
          Math.abs(siblings[POINT_COUNT - 2].speed.y))
    } else if (index === 0) {
      return (point.speed === siblings[1].speed)
        ? new Speed()
        : new Speed(
          Math.abs(siblings[1].speed.x),
          Math.abs(siblings[1].speed.y))
    } else {
      return new Speed(
        Math.abs(siblings[index - 1].speed.x),
        Math.abs(siblings[index - 1].speed.y))
    }
  }

  function movePoint(point, siblings, index) {
    point.x += point.speed.x
    point.y += point.speed.y

    let nextSpeed = calculateNextSpeed(point, siblings, index)

    if (point.x < 0) {
      point.y += calculateSpeedReduction(point.speed.y, point.speed.x, point.x, 0)
      point.x = 0
      point.speed.x = -Math.sign(point.speed.x) * nextSpeed.x
      point.speed.y = Math.sign(point.speed.y) * nextSpeed.y
    }

    if (point.x > WIDTH) {
      point.y += calculateSpeedReduction(point.speed.y, point.speed.x, point.x, WIDTH)
      point.x = WIDTH
      point.speed.x = -Math.sign(point.speed.x) * nextSpeed.x
      point.speed.y = Math.sign(point.speed.y) * nextSpeed.y
    }

    if (point.y < 0) {
      point.x += calculateSpeedReduction(point.speed.x, point.speed.y, point.y, 0)
      point.y = 0
      point.speed.x = Math.sign(point.speed.x) * nextSpeed.x
      point.speed.y = -Math.sign(point.speed.y) * nextSpeed.y
    }

    if (point.y > HEIGHT) {
      point.x += calculateSpeedReduction(point.speed.x, point.speed.y, point.y, HEIGHT)
      point.y = HEIGHT
      point.speed.x = Math.sign(point.speed.x) * nextSpeed.x
      point.speed.y = -Math.sign(point.speed.y) * nextSpeed.y
    }
  }

  function moveNode(node) {
    for (let i = 0; i < POINT_COUNT; i++) {
      movePoint(node.points[i], node.points, i)
    }
  }

  function moveShape(shape) {
    for (let i = 0; i < NODE_COUNT; i++) {
      moveNode(shape.nodes[i])
    }
  }

  function move() {
    for (let i = 0; i < SHAPE_COUNT; i++) {
      moveShape(SHAPES[i])
      stepColor(SHAPES[i])
    }
  }


  /* -------------------------------------------------------------------------- */


  function clear() {
    C.fillStyle = 'black'
    C.fillRect(0, 0, CANVAS.width, CANVAS.height)
  }

  function drawLine(startPoint, endPoint) {
    C.beginPath()
    C.moveTo(
      startPoint.x,
      startPoint.y,
    )
    C.lineTo(
      endPoint.x,
      endPoint.y,
    )
    C.closePath();
    C.stroke();
  }

  function drawShape(shape) {
    C.strokeStyle = shape.color.toString()
    C.lineWidth = 1
    for (let trailIndex = 0; trailIndex < POINT_COUNT; trailIndex++) {
      for (let nodeIndex = 0; nodeIndex < NODE_COUNT; nodeIndex++) {
        if (nodeIndex === NODE_COUNT - 1)
          drawLine(
            shape.nodes[nodeIndex].points[trailIndex],
            shape.nodes[0].points[trailIndex]
          )
        else
          drawLine(
            shape.nodes[nodeIndex].points[trailIndex],
            shape.nodes[nodeIndex + 1].points[trailIndex]
          )
      }
    }
  }

  function draw() {
    C.save()
    C.scale(SCALE, SCALE)
    clear()
    for (let i = 0; i < SHAPE_COUNT; i++)
      drawShape(SHAPES[i])
    C.restore()
  }


  /* -------------------------------------------------------------------------- */


  function resizeCanvas() {
    CANVAS.width = window.innerWidth
    WIDTH = CANVAS.width
    CANVAS.height = window.innerHeight
    HEIGHT = CANVAS.height
  }

  function resetShapes() {
    SHAPES = []
    for (let i = 0; i < SHAPE_COUNT; i++)
      SHAPES.push(new Shape())
  }

  function resetInterval() {
    FRAME_INTERVAL = 1000 / FPS
    THEN = Date.now();
    START_TIME = THEN;
  }

  function init() {
    resizeCanvas()
    resetShapes()
    resetInterval()
    update()
  }

  function update() {
    window.requestAnimationFrame(update);

    NOW = Date.now();
    ELAPSED = NOW - THEN;

    if (ELAPSED > FRAME_INTERVAL) {
      THEN = NOW - (ELAPSED % FRAME_INTERVAL);
      move()
      draw()
    }
  }

  init()
  window.addEventListener('resize', init, false);

</script>
</body>

</html>
